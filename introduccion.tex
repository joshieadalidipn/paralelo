
\section{Introducción}

\subsection{Muestra el contexto de la serie de Fourier}

Antes de la serie de fourier, el análisis de las ecuaciones era un proceso complicado, normalmente si se tenía una ecuación, se tenía dos caminos, analizar sus partes para resolverlo, o realizar una transformación logarítmica, lo cual simplificaba su análisis, para después realizar una transformación logarítmica inversa.

En 1748, Jean Baptiset Joseph Fourier estudió los movimientos vibratorios de una cuerda, notando una forma de vibración sinusoidal armónica. Con esto presente, concluyó que sería posible que en la configuración de la cuerda sería posible representarlo como una combinación lineal de modos normales que serían válidos para los instantes siguientes de tiempo.

Fue así como en 1807 presentó a la Academia Francesa de las Ciencias resultados de estudios de transmisión de calor, presentando un método de resolución para sus ecuaciones, la cual sería nombrada como la Transformada de Fourier, que, aunque se le otorgó un premio por ello, no presentaba resultados rigurosos.

En dicho trabajo se afirma que cualquier distribución calórica podría descomponerse en una suma de distribuciones espaciales sinusoidales. A esta representación se le conoce como Serie de Fourier. Esta afirmación recibió objeciones debido a que se dudaba si era posible que una función discontinua pudiera representarse de esa manera.

En 1829, Durucgket revisó su trabajo, y estableció las condiciones necesarias para que una función continua pueda representarse así, de forma que ahora todas las magnitudes físicas era posible representarlas y analizarlas por medio de las teorías de Fourier.

Con ello, la Transformada de Fourier fué posible conseguir un cambio de dominio, de modo que era posible traspasar la información contenida dentro de una señal con un dominio temporal o espacial hacia la frecuencia y viceversa, por lo que era posible realizar un análisis de dicha señal de una mejor manera.

\subsection{Cómo se ha aplicado el análisis de Fourier en la ciencia}

Una de las primeras aplicaciones de la serie de Fourier en un caso práctico fué a finales del siglo XIX, donde Lord Kelvin diseñó una computadora analógica con el fin de predecir el flujo y reflujo de las mareas, donde se utiliza el análisis de Fourier para obtener su periodicidad, de ciertos fenómenos ocurridos dentro de un intervalo de tiempo.

En este caso, se demostró que la exactitud de los resultados mejoró debido al incremento de componentes dentro de las frecuencias calculadas, por lo que, si una señal analizada se reconstruye con estos componentes, el error sería más pequeño cuanto mayor fuese el número de éstas.

En 1960, James W. Cooley junto con John W. Turkey, crearon un algoritmo conocido como la Transformada Rápida de Fourier (FFT por sus siglas en inglés Fast Fourier Transform), el cual lograba economizar el tiempo de cálculo reduciendo el número de multiplicaciones necesarias para el análisis frecuencial.

Con ello, es posible crear métodos para la resolución de ecuaciones difíciles, tal como las respuestas dinámicas de Sistemas eléctricos, lumínicos y térmicos. En otros casos, permite identificar las aportaciones de índole regular a una señal fluctuante.

En 1962, gracias a las técnicas de difracción de rayos X, y el análisis de Fourier, fue posible descubrir la forma doble hélice del ADN, pues con Fourier es posible mejorar el contenido de las imágenes para resaltar la información presente en la misma.

\subsection{Cómo se ha aplicado el análisis de Fourier en la tecnología}

El análisis de Fourier es super útil en muchas áreas, incluso en cosas que usamos todos los días pero quizás no lo notamos. Vamos a ver cómo se aplica en diferentes campos.

Primero, en telecomunicaciones, el análisis de Fourier es clave. Por ejemplo, en la modulación de frecuencia, que es como las radios transmiten música y voz. Lo que hacen es cambiar la frecuencia de una onda para enviar información. Luego está la compresión de audio, donde descomponen los sonidos en varias frecuencias para quitar partes que no necesitamos y hacer los archivos más pequeños. Y también ayuda a quitar ruido de las grabaciones, seleccionando solo las partes importantes de una señal.

En el procesamiento de imágenes, Fourier también es muy útil. Se usa para mejorar o quitar cosas de las fotos con algo llamado filtrado de imágenes. Esto puede hacer que algunas cosas se vean mejor o peor, dependiendo de lo que necesites. También ayuda a hacer las fotos más pequeñas sin perder mucha calidad, algo super útil para enviar imágenes por internet. Y algo muy beneficioso es que ayuda a que las computadoras reconozcan cosas en las fotos, como rostros al alcance de una aplicación.

En ingeniería, este análisis es muy importante. Por ejemplo, ayuda a entender cómo vibran las cosas para asegurarse de que no se van a romper. Diseñar filtros para señales es otro uso, como cuando quieres escuchar algo específico y quitar el resto. Y analizar señales eléctricas para saber qué está pasando en un circuito o sistema.

En ciencia y medicina, el análisis de Fourier también tiene su lugar. Se usa para entender las sustancias a nivel molecular con algo llamado análisis espectral. La resonancia magnética nuclear (RMN), que ayuda a ver dentro del cuerpo humano, usa Fourier para crear las imágenes. Y en el estudio del cerebro, como con la electroencefalografía (EEG), también es crucial para analizar las ondas cerebrales.

Entonces, aunque parezca algo muy técnico y complicado, el análisis de Fourier está en muchas partes de nuestra vida diaria, ayudando en cosas desde escuchar música hasta la medicina avanzada.

\subsection{Cómo se ha aplicado el análisis de Fourier en la ingeniería}

El análisis de Fourier en la ingeniería es fundamental y se aplica de diversas maneras. Empezando por el análisis de vibraciones, es esencial para entender cómo las estructuras como edificios o puentes responden a diferentes frecuencias de vibración. Esto es crucial porque ayuda a prevenir fallos estructurales. Por ejemplo, al estudiar cómo vibra un puente, se pueden tomar medidas para evitar que entre en resonancia y posiblemente colapse. Este análisis no solo se limita a grandes estructuras, sino que también se aplica en la evaluación de la vida útil de componentes mecánicos, identificando signos de desgaste antes de que fallen.

El diseño de filtros es otra aplicación importante. En este contexto, los filtros se utilizan para eliminar o atenuar frecuencias específicas dentro de una señal, mejorando así su calidad o extrayendo información relevante. Por ejemplo, en el mundo del audio, los filtros permiten separar o enfatizar ciertos sonidos, mientras que en telecomunicaciones, ayudan a limpiar la señal de ruido indeseado. Los principios de Fourier son esenciales para diseñar estos filtros, ya que proporcionan una manera de descomponer las señales en sus componentes de frecuencia y trabajar con ellos de manera más efectiva.

En lo que respecta al análisis de señales eléctricas, es vital para diagnosticar problemas en sistemas eléctricos y electrónicos. Al descomponer una señal eléctrica en sus componentes de frecuencia, los ingenieros pueden identificar anomalías como armónicos indeseados que pueden indicar fallos en el sistema. Además, este análisis es fundamental en la medición de la potencia eléctrica, ayudando a entender cómo se consume o genera energía en un sistema, y en el procesamiento de señales de control, donde se busca implementar controles más precisos y eficientes para, por ejemplo, ajustar la velocidad de un motor.

Finalmente, aunque ya hemos tocado algunos ejemplos previamente, es importante resaltar que el análisis de Fourier no se limita a estas áreas. Se extiende a otros campos como el procesamiento de imágenes, las telecomunicaciones y la medicina, demostrando su versatilidad y la importancia que tiene en el vasto mundo de la ingeniería. En cada uno de estos casos, la capacidad de analizar y manipular las frecuencias de una señal abre puertas a soluciones innovadoras y mejoras significativas en la tecnología y la calidad de vida.

Podemos darnos cuenta de que el análisis de Fourier es más que solo una herramienta matemática; es una llave maestra que permite a los ingenieros y científicos resolver una amplia gama de problemas prácticos, haciendo nuestra tecnología más eficiente, segura y capaz.

\subsection{Cómo se ha aplicado el análisis de Fourier en la inteligencia artificial}

Un método que se ha aplicado a una amplia gama de aplicaciones de inteligencia artificial (IA) es el análisis de Fourier. Su habilidad de descomponer señales en sus componentes de frecuencia la hace ideal para tareas que involucran el procesamiento de señales, como:

\begin{enumerate} \def\labelenumi{\alph{enumi}.} \item   \textbf{Reconocimiento de voz:} El análisis de Fourier se utiliza para   extraer características de las señales de voz que luego se pueden usar   para entrenar modelos de reconocimiento de voz. \item   \textbf{Procesamiento de imágenes:} El análisis de Fourier se puede   usar para analizar imágenes y extraer características como texturas,   bordes y formas. Estas características se pueden usar para tareas como   la clasificación de imágenes, la detección de objetos y el   reconocimiento facial. \item   \textbf{Compresión de datos:} El análisis de Fourier se puede usar   para comprimir datos al eliminar componentes de frecuencia que no son   perceptibles para el ser humano. Esto se utiliza en una variedad de   aplicaciones, como la compresión de imágenes y audio. \item   \textbf{Análisis de series temporales:} El análisis de Fourier se   puede usar para analizar series temporales, como datos financieros o   climáticos. Esto se puede usar para identificar tendencias, patrones y   anomalías en los datos. \item   \textbf{Síntesis de sonido:} El análisis de Fourier se puede usar para   sintetizar sonidos al combinar componentes de frecuencia específicos.   Esto se utiliza en una variedad de aplicaciones, como la creación de   música y efectos de sonido. \item   \textbf{Redes neuronales convolucionales (CNN):} Las CNN son un tipo   de red neuronal que se utiliza para el procesamiento de imágenes. Las   CNN utilizan filtros convolucionales que funcionan de manera similar   al análisis de Fourier para detectar características en las imágenes. \item   \textbf{Aprendizaje automático:} El análisis de Fourier se puede usar   como una herramienta de preprocesamiento para el aprendizaje   automático. Al descomponer las señales en sus componentes de   frecuencia, el análisis de Fourier puede ayudar a los modelos de   aprendizaje automático a identificar patrones y relaciones en los   datos. \end{enumerate}

A continuación se muestran unos ejemplos de las diferentes aplicaciones que tiene el análisis de Fourier:

\begin{itemize} \item   \textbf{DeepMind WaveNet:} WaveNet es un modelo de aprendizaje   automático que utiliza el análisis de Fourier para generar audio de   alta calidad. \item   \textbf{OpenAI Jukebox:} Jukebox es un modelo de aprendizaje   automático que utiliza el análisis de Fourier para generar música en   una variedad de estilos. \item   \textbf{Facebook DeepFace:} DeepFace es un modelo de reconocimiento   facial que utiliza el análisis de Fourier para extraer características   de las imágenes faciales. \end{itemize}

\subsection{Cómo se ha aplicado el análisis de Fourier en el cómputo paralelo}\label{cuxf3mo-se-ha-aplicado-el-anuxe1lisis-de-fourier-en-el-cuxf3mputo-paralelo}

Anteriormente hablamos sobre las aplicaciones del análisis de Fourier en la Inteligencia Artificial, sin embargo, un punto importante de destacar es que su implementación requiere de un alto costo computacional, especialmente cuando hablamos de conjuntos de datos grandes.

El cómputo paralelo ofrece una forma más sencilla y flexible de acelerar el análisis de Fourier al distribuir la carga de trabajo en diferentes procesadores, métodos o hilos que permitan un mejor desempeño y mayores beneficios, por ejemplo:

\begin{enumerate} \def\labelenumi{\alph{enumi}.} \item   \textbf{Reducción del tiempo de ejecución}: El análisis de Fourier se   puede realizar significativamente más rápido al distribuir la carga de   trabajo entre múltiples procesadores. \item   \textbf{Mejora de la escalabilidad}: El análisis de Fourier se puede   escalar a conjuntos de datos más grandes al utilizar más procesadores. \item   \textbf{Mayor eficiencia energética}: El cómputo paralelo puede ayudar   a reducir el consumo de energía al distribuir la carga de trabajo   entre múltiples procesadores. \end{enumerate}

El análisis de Fourier en paralelo se ha utilizado en una amplia gama de aplicaciones, incluyendo:

\begin{itemize} \item   \textbf{Algoritmos:} Se han desarrollado nuevos algoritmos para el   cálculo de la transformada de Fourier que son más eficientes en   paralelo. \item   \textbf{Hardware:} La disponibilidad de hardware de computación   paralela de alto rendimiento, como las GPU, ha hecho que el análisis   de Fourier en paralelo sea más accesible. \item   \textbf{Software:} Se han desarrollado bibliotecas de software para   facilitar la implementación del análisis de Fourier en paralelo. \end{itemize}

\begin{itemize} \item   \textbf{Aprendizaje automático:} El análisis de Fourier en paralelo se   está utilizando para acelerar el aprendizaje automático, como el   entrenamiento de redes neuronales profundas. \item   \textbf{Big data:} El análisis de Fourier en paralelo se está   utilizando para analizar conjuntos de datos grandes, como los   conjuntos de datos de sensores. \item   \textbf{IoT:} El análisis de Fourier en paralelo se está utilizando   para procesar datos en tiempo real de dispositivos IoT. \end{itemize}

\subsection{La teoría de procesos hijos con la llamada al sistema fork() en lenguaje C}\label{la-teoruxeda-de-procesos-hijos-con-la-llamada-al-sistema-fork-en-lenguaje-c}

La teoría de los procesos hijos con la llamada al sistema fork() en lenguaje C es fundamental en la programación de sistemas operativos Unix-like. fork() es una llamada al sistema que crea un nuevo proceso hijo idéntico al proceso padre. Este proceso hijo comparte el mismo código, datos y estado del proceso padre, pero tiene su propia copia de la tabla de descriptores de archivos.

El proceso padre puede continuar su ejecución después de llamar a fork(), mientras que el proceso hijo comienza su ejecución desde el mismo punto en el que se llamó a fork(). Esto permite la creación de procesos concurrentes que pueden ejecutar tareas independientes simultáneamente.

El manejo de los procesos hijos con fork() es crucial para la implementación de sistemas multi-tarea y paralelos, ya que permite la ejecución de múltiples tareas de forma concurrente. Además, fork() es la base sobre la que se construyen otras llamadas al sistema relacionadas con la gestión de procesos, como exec(), que se utiliza para cargar un nuevo programa en un proceso existente.

Algunos ejemplos sobre la implementación de fork() son:

\begin{itemize} \item   Creación de Procesos Concurrentes: fork() se utiliza para crear   procesos hijos que pueden ejecutar tareas simultáneamente con el   proceso padre. \item   Paralelismo: fork() se utiliza para ejecutar tareas en paralelo,   aprovechando múltiples núcleos de CPU. Por ejemplo, en un programa que   procesa datos en paralelo \item   Gestión de Procesos: fork() se utiliza en combinación con otras   llamadas al sistema para realizar tareas específicas, como la   ejecución de programas externos con exec(). \end{itemize}

\subsubsection{fork()}\label{fork}

Para utilizar la función fork() en un programa escrito en lenguaje C y destinado a ejecutarse en sistemas operativos basados en Linux, es necesario seguir una serie de pasos y consideraciones:

\textbf{Inclusión de cabeceras:} Al principio del programa, es necesario incluir las cabeceras de las funciones y estructuras que se utilizarán. Para fork(), se incluye la cabecera \textless unistd.h\textgreater.

\textbf{Declaración de variables:} Es común declarar una variable de tipo \emph{\textbf{pid\_t}} para almacenar el resultado de la llamada a fork(). Esta variable se utiliza para determinar si el proceso actual es el proceso padre o el proceso hijo.

\textbf{Llamada a fork()}: Se utiliza la función fork() en el punto del programa donde se desea crear un nuevo proceso hijo. La función devuelve un valor que indica el resultado de la llamada. Si es 0, se está ejecutando en el proceso hijo. Si es mayor que 0, se está ejecutando en el proceso padre y el valor devuelto es el PID (identificador de proceso) del proceso hijo. Si es -1, indica un error en la llamada a fork().

\textbf{Manejo de errores:} Es importante verificar el resultado de la llamada a fork() para detectar posibles errores. Si la llamada devuelve -1, se debe manejar el error adecuadamente, por ejemplo, imprimiendo un mensaje de error y saliendo del programa.

\textbf{Código específico para cada proceso:} Una vez que se ha llamado a fork(), el programa se bifurca en dos procesos: el proceso padre y el proceso hijo. Es necesario escribir el código específico para cada uno de estos procesos, ya que ambos continuarán ejecutándose a partir del punto de bifurcación.

\textbf{Comunicación entre procesos:} Si es necesario que los procesos se comuniquen entre sí, es posible utilizar mecanismos de comunicación como tuberías (pipes), memoria compartida o semáforos, entre otros.

\subsection{Memoria compartida en lenguaje C}\label{memoria-compartida-en-lenguaje-c}

La memoria compartida es un mecanismo de comunicación entre procesos (IPC) que permite a múltiples procesos acceder y modificar una región de memoria física de forma simultánea. Esto resulta particularmente útil en entornos de programación paralela, donde varios procesos colaboran en la ejecución de una tarea. En C, la memoria compartida se implementa utilizando funciones del sistema POSIX (Portable Operating System Interface) o mediante la biblioteca Windows API.

\subsubsection{Principios Fundamentales}\label{principios-fundamentales}

\textbf{Espacio de Memoria Común}: La memoria compartida crea una región de memoria física accesible para todos los procesos involucrados. Esta región no pertenece a ningún proceso en particular, sino que se comparte entre ellos.

\textbf{Acceso Sincronizado}: Para evitar conflictos de datos, el acceso a la memoria compartida debe ser sincronizado. Los mecanismos de sincronización, como semáforos o mutexes, garantizan que solo un proceso pueda acceder a una sección crítica de la memoria en un momento dado.

\textbf{Mapeo de Memoria}: Cada proceso que desea acceder a la memoria compartida debe mapearla en su propio espacio de direcciones virtual. Esto permite que el proceso trate la región compartida como si fuera parte de su propia memoria privada.

\subsubsection{Ventajas de la Memoria Compartida}\label{ventajas-de-la-memoria-compartida}

\textbf{Comunicación Eficiente}: La memoria compartida ofrece una forma de comunicación entre procesos (IPC) muy eficiente, especialmente cuando se requiere un alto rendimiento y baja latencia.

\textbf{Acceso Directo a Datos}: Los procesos pueden acceder y modificar directamente los datos en la memoria compartida, sin necesidad de realizar copias o pasar mensajes.

\textbf{Flexibilidad}: La memoria compartida puede usarse para compartir cualquier tipo de dato, desde estructuras simples hasta grandes matrices multidimensionales.

\subsubsection{Desventajas de la Memoria Compartida}\label{desventajas-de-la-memoria-compartida}

\textbf{Complejidad:} La implementación de la memoria compartida puede ser más compleja que otros mecanismos de IPC, como la mensajería de colas o las tuberías.

\textbf{Problemas de Sincronización}: La sincronización del acceso a la memoria compartida es crucial para evitar conflictos de datos y garantizar la integridad de los datos.

\textbf{Seguridad:} La memoria compartida puede ser vulnerable a ataques si no se implementan las medidas de seguridad adecuadas.

\subsubsection{Estructura de un Programa con Memoria Compartida}\label{estructura-de-un-programa-con-memoria-compartida}

Un programa típico que utiliza memoria compartida en C consta de las siguientes etapas:

\textbf{Creación de la Memoria Compartida}: El primer proceso crea la región de memoria compartida utilizando funciones del sistema POSIX o Windows API. Se especifica el tamaño de la región y se asigna un nombre único.

\textbf{Mapeo de la Memoria Compartida}: Cada proceso que desea acceder a la memoria compartida la mapea en su propio espacio de direcciones virtual. Se utiliza la dirección de memoria compartida obtenida en la etapa anterior.

\textbf{Acceso y Modificación de Datos}: Los procesos acceden y modifican los datos en la memoria compartida utilizando punteros. Se deben utilizar mecanismos de sincronización para evitar conflictos de datos.

\textbf{Desvinculación de la Memoria Compartida}: Cuando un proceso ya no necesita acceder a la memoria compartida, la desvincula de su espacio de direcciones virtual.

\textbf{Destrucción de la Memoria Compartida}: El último proceso que finaliza libera la memoria compartida utilizando funciones del sistema POSIX o Windows API.

\subsubsection{Ejemplos de Uso de la Memoria Compartida}\label{ejemplos-de-uso-de-la-memoria-compartida}

\textbf{Implementación de Cachés:} La memoria compartida se puede usar para implementar cachés compartidos entre procesos, lo que mejora el rendimiento al reducir el acceso a datos lentos como el disco duro.

\textbf{Comunicación en Sistemas Multihilo}: La memoria compartida se puede usar para la comunicación entre hilos de ejecución dentro de un mismo proceso, lo que permite una colaboración eficiente entre ellos.

\textbf{Programación Paralela}: La memoria compartida es un mecanismo fundamental para la programación paralela, ya que permite a múltiples procesos compartir datos y colaborar en la ejecución de una tarea compleja.

\subsection{Semáforos en lenguaje C}\label{semuxe1foros-en-lenguaje-c}

Los semáforos son un mecanismo de sincronización fundamental en la programación concurrente, particularmente en el lenguaje C. Permiten controlar el acceso a recursos compartidos entre múltiples procesos o hilos de ejecución, evitando conflictos de datos y garantizando la integridad de la información.

\subsubsection{Principios Fundamentales}\label{principios-fundamentales-1}

\begin{enumerate} \def\labelenumi{\arabic{enumi}.} \item   Recursos Compartidos: Los semáforos protegen recursos compartidos,   como variables, estructuras de datos o secciones de código. Cada   recurso compartido está asociado a un semáforo específico. \item   Valor del Semáforo: El valor de un semáforo representa el número de   unidades de acceso disponibles al recurso compartido asociado. Un   valor positivo indica que el recurso está disponible, mientras que un   valor cero indica que el recurso está actualmente en uso. \item   Operaciones Básicas: Las operaciones básicas sobre semáforos son:

          \begin{itemize}   \item     P(sem): Decrementa el valor del semáforo en una unidad. Si el valor     es cero, el proceso se bloquea hasta que el valor se incrementa a     uno, liberando el recurso.   \item     V(sem): Incrementa el valor del semáforo en una unidad. Si hay     procesos bloqueados esperando por el recurso, uno de ellos se libera     y puede continuar su ejecución.   \end{itemize} \end{enumerate}

\subsubsection{Implementación de Semáforos en C}\label{implementaciuxf3n-de-semuxe1foros-en-c}

En C, los semáforos se implementan utilizando funciones del sistema POSIX (Portable Operating System Interface). Las funciones principales son:

\begin{itemize} \item   sem\_open(): Crea o abre un semáforo existente. \item   sem\_wait(): Decrementa el valor del semáforo y bloquea el proceso si   es necesario. \item   sem\_post(): Incrementa el valor del semáforo y libera un proceso   bloqueado si hay alguno esperando. \item   sem\_close(): Cierra un semáforo. \item   sem\_unlink(): Elimina un semáforo del sistema. \end{itemize}

Ventajas de los Semáforos

\textbf{Sincronización Eficiente}: Los semáforos proporcionan una forma eficiente de sincronizar el acceso a recursos compartidos entre múltiples procesos o hilos.

\textbf{Prevención de Conflictos de Datos}: Los semáforos evitan conflictos de datos al garantizar que solo un proceso acceda a un recurso crítico a la vez.

\textbf{Flexibilidad}: Los semáforos se pueden utilizar para sincronizar una amplia gama de recursos compartidos, desde variables simples hasta estructuras de datos complejas.

\subsubsection{Desventajas de los Semáforos}\label{desventajas-de-los-semuxe1foros}

\textbf{Problemas de Bloqueo:} Si los semáforos no se utilizan correctamente, pueden surgir problemas de bloqueo, donde los procesos se bloquean esperando recursos que nunca estarán disponibles.

\textbf{Exclusión Mutua Estricta:} Los semáforos solo permiten la exclusión mutua estricta, lo que significa que solo un proceso puede acceder a un recurso crítico a la vez. Esto puede ser un problema en situaciones donde se requiere acceso simultáneo a partes no críticas del recurso.

\subsection{Hilos en lenguaje C}\label{hilos-en-lenguaje-c}

Un hilo (o thread en inglés) es un simple flujo de control secuencial, donde se ejecutan una serie de instrucciones linealmente, donde tiene un principio y un fin.

Cuando un hilo crea múltiples hilos, se le conoce como ``ejecución multihilo'' (o multi thread en inglés), donde se crean varias líneas de ejecución de un mismo programa, donde cada hilo está conectado a las mismas localidades de memoria que todos los hilos, pero la gestión de los hilos es responsabilidad del programador.

\subsubsection{Características de los hilos}\label{caracteruxedsticas-de-los-hilos}

Los hilos logran que un programa se vuelva muy eficiente cuando puede explotar los recursos disponibles de una manera aceptable, todos los hilos comparten características entre ellas:

\begin{itemize} \item   El espacio de direcciones \item   El ID del proceso \item   El ID del proceso padre \item   El ID del proceso líder del grupo \item   Los identificadores de usuario y grupo \item   El directorio de trabajo raiz y actual \item   La tabla de descriptores de archivos \item   El timer de proceso \end{itemize}

Los hilos también poseen características que no comparten con sus pares, tales como:

\begin{itemize} \item   Un identificador de hilo unico \item   La política de planificación y prioridad \item   Una variable errno por hilo \item   Datos específicos por hilo \item   Gestores de cancelación por hilo \item   Máscara de señales por hilo \end{itemize}

Y las operaciones posibles dentro de un hilo son:

\begin{itemize} \item   Creacion y destruccion \item   Sincronización entre hilos \item   Posibilidad de disponer para cada hilo memoria compartida \item   Gestión de prioridades entre hilos y de señales. \end{itemize}

\subsubsection{Implementación de Hilos en C}\label{implementaciuxf3n-de-hilos-en-c}

Las funciones posibles para gestionar los hilos son:

\begin{itemize} \item   pthread\_create: crea un hilo \item   pthread\_equal: verifica la igualdad de dos identificadores de hilo \item   pthread\_exit: termina el hilo que realiza la llamada \item   pthread\_join: espera por el término de un hilo específico \item   pthread\_self: regresa el ID del hilo que realiza la llamada \item   pthread\_detach: configura la liberación de recursos cuando termina   (hilo independiente) \item   pthread\_getschedparam: obtiene la política de planificación y   parámetros de un hilo específico \item   pthread\_setschedparam: establece la política de planificación y   parámetros de un hilo especifico \item   pthread\_kill: envía una señal de terminar a un hilo específico \item   pthread\_cancel: Permite a un hilo cancelar otro hilo del mismo   proceso. \end{itemize}

